From 90f784900a850a92126526de0c172aa8ad51923f Mon Sep 17 00:00:00 2001
From: Gonzalo Odiard <godiard@gmail.com>
Date: Fri, 7 Mar 2014 16:30:13 -0300
Subject: [PATCH] Move class HiddenNetworkManager to network.py

This is needed to use it by the shell too.

Signed-off-by: Gonzalo Odiard <gonzalo@laptop.org>
---
 extensions/cpsection/network/model.py | 151 ---------------------------------
 extensions/cpsection/network/view.py  |   2 +-
 src/jarabe/model/network.py           | 154 ++++++++++++++++++++++++++++++++++
 3 files changed, 155 insertions(+), 152 deletions(-)

diff --git a/extensions/cpsection/network/model.py b/extensions/cpsection/network/model.py
index 9f4164f..dddc879 100644
--- a/extensions/cpsection/network/model.py
+++ b/extensions/cpsection/network/model.py
@@ -18,7 +18,6 @@
 import logging
 
 import dbus
-import uuid
 import os
 from ConfigParser import ConfigParser
 
@@ -219,153 +218,3 @@ def parameter_as_boolean(profile, parameter):
     if parameter in profile:
         value = profile[parameter].upper() in ('1', 'TRUE', 'YES')
     return value
-
-
-class HiddenNetworkManager():
-
-    def __init__(self, conn_profiles={}):
-        client = GConf.Client.get_default()
-        self.enabled = client.get_bool(
-            '/desktop/sugar/extensions/network/conf_hidden_ssid')
-        if not self.enabled:
-            logging.debug('Hidden network configuration disabled')
-            return
-        try:
-            self._bus = dbus.SystemBus()
-            self._netmgr = network.get_manager()
-        except dbus.DBusException:
-            logging.debug('NetworkManager not available')
-            return
-
-        self._netmgr.GetDevices(reply_handler=self.__get_devices_reply_cb,
-                                error_handler=self.__get_devices_error_cb)
-
-        # get the list of connectivity profiles of type "connectivity"
-        self.network_profiles = []
-        logging.debug('profiles %s', conn_profiles)
-        for profile_key in conn_profiles:
-            profile = conn_profiles[profile_key]
-            if profile['type'] == 'connectivity':
-                self.network_profiles.append(profile)
-        self.selected_profile = None
-
-    def __get_devices_reply_cb(self, devices_o):
-        logging.debug('__get_devices_reply_cb len(devices) = %d',
-                      len(devices_o))
-        for dev_o in devices_o:
-            self._check_device(dev_o)
-
-    def __get_devices_error_cb(self, err):
-        logging.error('Failed to get devices: %s', err)
-
-    def _check_device(self, device_o):
-        device = self._bus.get_object(network.NM_SERVICE, device_o)
-        props = dbus.Interface(device, dbus.PROPERTIES_IFACE)
-
-        device_type = props.Get(network.NM_DEVICE_IFACE, 'DeviceType')
-        if device_type == network.NM_DEVICE_TYPE_WIFI:
-            state = props.Get(network.NM_DEVICE_IFACE, 'State')
-            if state == 100:  # Activated
-                self._active_device = device_o
-
-    def _get_device_path_error_cb(self, err):
-        logging.error('Failed to get device type: %s', err)
-
-    def create_and_connect_by_ssid(self, ssid):
-        connection = network.find_connection_by_ssid(ssid)
-        if connection is None:
-            # Th connection do not exists
-            settings = network.Settings()
-            settings.connection.id = ssid
-            settings.connection.type = \
-                network.NM_CONNECTION_TYPE_802_11_WIRELESS
-            settings.connection.uuid = str(uuid.uuid4())
-            settings.connection.autoconnect = True
-
-            settings.wireless.ssid = dbus.ByteArray(ssid)
-            settings.wireless.hidden = True
-            logging.debug('AddAndActivateConnection')
-            self._netmgr.AddAndActivateConnection(
-                settings.get_dict(),
-                self._active_device, '/',
-                reply_handler=self._add_connection_reply_cb,
-                error_handler=self._add_connection_error_cb)
-        else:
-            logging.debug('ActivateConnection')
-            self._netmgr.ActivateConnection(
-                connection.get_path(),
-                self._active_device, '/')
-
-    def create_and_connect_by_profile(self):
-        """
-        A profile is a dictionary with a format like this
-        profile {'title': 'Queensland', 'type': 'connectivity',
-            'connection.id': 'QDETA-X',
-            'connection.type': '802-11-wireless',
-            '802-1x.eap': 'peap',
-            '802-1x.identity': 'uuuuu',
-            '802-1x.password': 'pppppp',
-            '802-1x.phase2-auth': 'mschapv2',
-            '802-11-wireless.security': '802-11-wireless-security',
-            '802-11-wireless.ssid': 'QDETA-X',
-            '802-11-wireless-security.key-mgmt': 'wpa-eap',
-            'ipv4.method': 'auto',
-                }
-        """
-        if self.selected_profile is None:
-            logging.error('No profile selected')
-            return
-
-        profile = self.selected_profile
-        connection = network.find_connection_by_ssid(profile['connection.id'])
-        if connection is None:
-            # Th connection do not exists
-            settings = network.Settings()
-            settings.connection.id = profile['connection.id']
-            settings.connection.type = profile['connection.type']
-            settings.connection.uuid = str(uuid.uuid4())
-            settings.connection.autoconnect = True
-
-            settings.wireless.ssid = dbus.ByteArray(
-                profile['802-11-wireless.ssid'])
-            settings.wireless.hidden = True
-
-            if '802-11-wireless.security' in profile and \
-                    profile['802-11-wireless.security'].upper() not in \
-                    ('', 'NONE'):
-                settings.wireless_security = network.WirelessSecurity()
-                settings.wireless_security.key_mgmt = \
-                    profile['802-11-wireless-security.key-mgmt']
-
-                if settings.wireless_security.key_mgmt == 'wpa-eap':
-                    settings.wpa_eap_setting = network.EapSecurity()
-                    settings.wpa_eap_setting.eap = profile['802-1x.eap']
-                    settings.wpa_eap_setting.identity = profile[
-                        '802-1x.identity']
-                    settings.wpa_eap_setting.password = profile[
-                        '802-1x.password']
-                    settings.wpa_eap_setting.phase2_auth = profile[
-                        '802-1x.phase2-auth']
-
-            if 'ipv4.method' in profile and \
-                    profile['ipv4.method'].upper() not in ('', 'NONE'):
-                settings.ip4_config = network.IP4Config()
-                settings.ip4_config.method = profile['ipv4.method']
-
-            logging.error('createby_profile %s', settings.get_dict())
-
-            self._netmgr.AddAndActivateConnection(
-                settings.get_dict(),
-                self._active_device, '/',
-                reply_handler=self._add_connection_reply_cb,
-                error_handler=self._add_connection_error_cb)
-        else:
-            self._netmgr.ActivateConnection(
-                connection.get_path(),
-                self._active_device, '/')
-
-    def _add_connection_reply_cb(self, netmgr, connection):
-        logging.debug('Added connection: %s', connection)
-
-    def _add_connection_error_cb(self, err):
-        logging.error('Failed to add connection: %s', err)
diff --git a/extensions/cpsection/network/view.py b/extensions/cpsection/network/view.py
index b1f16dd..c942889 100644
--- a/extensions/cpsection/network/view.py
+++ b/extensions/cpsection/network/view.py
@@ -27,7 +27,7 @@ from sugar3.graphics import style
 from jarabe.controlpanel.sectionview import SectionView
 from jarabe.controlpanel.inlinealert import InlineAlert
 
-from model import HiddenNetworkManager
+from jarabe.model.network import HiddenNetworkManager
 
 CLASS = 'Network'
 ICON = 'module-network'
diff --git a/src/jarabe/model/network.py b/src/jarabe/model/network.py
index 5edb2a4..18ed79d 100644
--- a/src/jarabe/model/network.py
+++ b/src/jarabe/model/network.py
@@ -595,6 +595,160 @@ class SecretsResponse(object):
         self._error_cb(error)
 
 
+class HiddenNetworkManager():
+
+    def __init__(self, conn_profiles={}):
+        client = GConf.Client.get_default()
+        self.enabled = client.get_bool(
+            '/desktop/sugar/extensions/network/conf_hidden_ssid')
+        if not self.enabled:
+            logging.debug('Hidden network configuration disabled')
+            return
+        try:
+            self._bus = dbus.SystemBus()
+            self._netmgr = get_manager()
+        except dbus.DBusException:
+            logging.debug('NetworkManager not available')
+            return
+
+        self._netmgr.GetDevices(reply_handler=self.__get_devices_reply_cb,
+                                error_handler=self.__get_devices_error_cb)
+
+        # get the list of connectivity profiles of type "connectivity"
+        self.network_profiles = []
+        logging.debug('profiles %s', conn_profiles)
+        for profile_key in conn_profiles:
+            profile = conn_profiles[profile_key]
+            if profile['type'] == 'connectivity':
+                self.network_profiles.append(profile)
+        self.selected_profile = None
+
+    def __get_devices_reply_cb(self, devices_o):
+        logging.debug('__get_devices_reply_cb len(devices) = %d',
+                      len(devices_o))
+        for dev_o in devices_o:
+            self._check_device(dev_o)
+
+    def __get_devices_error_cb(self, err):
+        logging.error('Failed to get devices: %s', err)
+
+    def _check_device(self, device_o):
+        logging.debug('_check_device %s', device_o)
+        device = self._bus.get_object(NM_SERVICE, device_o)
+        props = dbus.Interface(device, dbus.PROPERTIES_IFACE)
+        device_type = props.Get(NM_DEVICE_IFACE, 'DeviceType')
+        logging.debug('device_type = %s', device_type)
+        if device_type == NM_DEVICE_TYPE_WIFI:
+            state = props.Get(NM_DEVICE_IFACE, 'State')
+            logging.debug('state %s', state)
+            if state == 100:  # Activated
+                self._active_device = device_o
+
+    def _get_device_path_error_cb(self, err):
+        logging.error('Failed to get device type: %s', err)
+
+    def create_and_connect_by_ssid(self, ssid):
+        logging.debug('create_and_connect_by_ssid ssid=%s', ssid)
+        connection = find_connection_by_ssid(ssid)
+        if connection is None:
+            logging.error('connection is None')
+            # Th connection do not exists
+            settings = Settings()
+            settings.connection.id = ssid
+            settings.connection.type = \
+                NM_CONNECTION_TYPE_802_11_WIRELESS
+            settings.connection.uuid = str(uuid.uuid4())
+            settings.connection.autoconnect = True
+
+            settings.wireless.ssid = dbus.ByteArray(ssid)
+            settings.wireless.hidden = True
+            logging.debug('AddAndActivateConnection')
+            self._netmgr.AddAndActivateConnection(
+                settings.get_dict(),
+                self._active_device, '/',
+                reply_handler=self._add_connection_reply_cb,
+                error_handler=self._add_connection_error_cb)
+        else:
+            logging.debug('ActivateConnection')
+            self._netmgr.ActivateConnection(
+                connection.get_path(),
+                self._active_device, '/')
+
+    def create_and_connect_by_profile(self):
+        """
+        A profile is a dictionary with a format like this
+        profile {'title': 'Queensland', 'type': 'connectivity',
+            'connection.id': 'QDETA-X',
+            'connection.type': '802-11-wireless',
+            '802-1x.eap': 'peap',
+            '802-1x.identity': 'uuuuu',
+            '802-1x.password': 'pppppp',
+            '802-1x.phase2-auth': 'mschapv2',
+            '802-11-wireless.security': '802-11-wireless-security',
+            '802-11-wireless.ssid': 'QDETA-X',
+            '802-11-wireless-security.key-mgmt': 'wpa-eap',
+            'ipv4.method': 'auto',
+                }
+        """
+        if self.selected_profile is None:
+            logging.error('No profile selected')
+            return
+
+        profile = self.selected_profile
+        connection = find_connection_by_ssid(profile['connection.id'])
+        if connection is None:
+            # Th connection do not exists
+            settings = Settings()
+            settings.connection.id = profile['connection.id']
+            settings.connection.type = profile['connection.type']
+            settings.connection.uuid = str(uuid.uuid4())
+            settings.connection.autoconnect = True
+
+            settings.wireless.ssid = dbus.ByteArray(
+                profile['802-11-wireless.ssid'])
+            settings.wireless.hidden = True
+
+            if '802-11-wireless.security' in profile and \
+                    profile['802-11-wireless.security'].upper() not in \
+                    ('', 'NONE'):
+                settings.wireless_security = WirelessSecurity()
+                settings.wireless_security.key_mgmt = \
+                    profile['802-11-wireless-security.key-mgmt']
+
+                if settings.wireless_security.key_mgmt == 'wpa-eap':
+                    settings.wpa_eap_setting = EapSecurity()
+                    settings.wpa_eap_setting.eap = profile['802-1x.eap']
+                    settings.wpa_eap_setting.identity = profile[
+                        '802-1x.identity']
+                    settings.wpa_eap_setting.password = profile[
+                        '802-1x.password']
+                    settings.wpa_eap_setting.phase2_auth = profile[
+                        '802-1x.phase2-auth']
+
+            if 'ipv4.method' in profile and \
+                    profile['ipv4.method'].upper() not in ('', 'NONE'):
+                settings.ip4_config = IP4Config()
+                settings.ip4_config.method = profile['ipv4.method']
+
+            logging.error('createby_profile %s', settings.get_dict())
+
+            self._netmgr.AddAndActivateConnection(
+                settings.get_dict(),
+                self._active_device, '/',
+                reply_handler=self._add_connection_reply_cb,
+                error_handler=self._add_connection_error_cb)
+        else:
+            self._netmgr.ActivateConnection(
+                connection.get_path(),
+                self._active_device, '/')
+
+    def _add_connection_reply_cb(self, netmgr, connection):
+        logging.debug('Added connection: %s', connection)
+
+    def _add_connection_error_cb(self, err):
+        logging.error('Failed to add connection: %s', err)
+
+
 def set_connected():
     try:
         # try to flush resolver cache - SL#1940
-- 
1.8.1.4

